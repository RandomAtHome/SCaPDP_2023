
Задание на осень.
Для выполнения практических заданий используется суперкомпьютер K10:
https://www.kiam.ru/MVS/resourses/k10.html

В каждой задаче требуется:
1) Для предложенного алгоритма реализовать несколько версий параллельных программ с использованием технологии OpenMP.
a) Вариант параллельной программы с распределением витков циклов при помощи директивы for.
б) Вариант параллельной программы с использованием механизма задач (директива task).
б') Для программ с регулярной зависимостью по данным вместо механизма задач допускается реализация и сравнение различных версий конвейерного выполнения циклов, параллелизм по гиперплоскостям и др.
2) Убедиться в корректности разработанных программ, используя Intel Parallel Inspector:
inspxe-cl
3) Подобрать начальные параметры для задачи, чтобы:
a) Задача помещалась в оперативную память одного узла кластера.
б) Время решения задачи было в примерном диапазоне 5 сек.-15 минут.
4) Исследовать эффективность полученных параллельных программ на суперкомпьютере K-10.
a) Сравнить варианты разработанных версий параллельных программ.
б) Сравнить времена выполнения программ при использовании различных компиляторов с поддержкой OpenMP:
GNU: gcc -fopenmp ...
Clang: clang -fopenmp ...
PGI: pgcc -mp ...
Intel: icc -qopenmp
в) Если в процессе распараллеливания программа была существенно оптимизирована/изменена/переписана (например, на С++) необходимо провести сравнение - исходная программа VS программа после преобразований.
г) Исследовать влияние различных опций оптимизации, которые поддерживаются компиляторами (-O2, -O3, -fast...)
5) Исследовать масштабируемость полученной параллельной программы: построить графики зависимости времени выполнения параллельной программы от числа используемых ядер для различного объёма входных данных.
Для каждого набора входных данных найти количество ядер, при котором время выполнения задачи перестаёт уменьшаться.
Оптимальным является построение трёхмерного графика: по одной из осей время работы программы, по другой - количество ядер и по третьей - объём входных данных.
Такой график необходимо построить для каждого из разработанных вариантов программы и для каждого компилятора.
Каждый прогон программы с новыми параметрами рекомендуется выполнять несколько раз с последующим усреднением результата (для избавления от случайных выбросов).
Для замера времени рекомендуется использовать функцию omp_get_wtime, общее время работы должно определяться временем работы самой медленной нити.
Количество ядер рекомендуется задавать в виде p=2n, n=0, 1, 2, ... , k, где k определяется доступными ресурсами.
6) Определить основные причины недостаточной масштабируемости программы при максимальном числе используемых ядер.
7) Подготовить отчет о выполнении задания, включающий: описание реализованного алгоритма, графики зависимости времени исполнения от числа ядер для различного объёма входных данных, тексты программ.


